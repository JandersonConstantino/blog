---
title: O que é ReasonML ? Parte 2
author: Marcos Oliveira
date: 2020-06-02
hero: ./images/hero.png
excerpt: Neste artigo basicamente irei explicar porque você deveria adotar ReasonML ao invés de TypeScript e Flow
---

## Introdução

De início quero me desculpar às pessoas que me pediram muito essa segunda parte da série _"O que é ReasonML?"_.
Ocorreram muitas mudanças desde o primeiro post e eu acabei deixando de lado essa série de artigos.
Nesta segunda parte, vou dar continuação ao artigo anterior, com objetivo de dar uma visão geral sobre o que é ReasonML, 
onde ele pode ser usado e o porque você deveria optar por ele ao invés de TypeScript ou Flow. 

Se você não leu a primeira parte deste artigo, pare, leia, e volte aqui para continuar. A primeira parte contém informações muito 
importantes sobre ReasonML e vai ser crucial para entender os tópicos que irei abordar aqui neste artigo.
Esta é a segunda parte da série, em breve quero começar outra que será _"Como dar os primeiros passos 
com ReasonML e React"_. Se tudo der certo, também devo lançar alguns vídeos no canal do [YT](https://www.youtube.com/channel/UCej3xR0REyuvYYAFz0SbswA) 
da [Lukin](https://lukin.co), onde vou passar o mesmo conteúdo sobre como iniciar em Reason com React, só que em formato de vídeo.

Bom era isso, sem mais delongas, vamos falar de Reason!

## Considerações sobre Reason nativo

O objetivo deste artigo não é falar sobre ReasonML na plataforma nativa. Porém, é impossível não 
mencionar o trabalho excepcional e com muito potencial que a comunidade Reason, vem fazendo na plataforma nativa.
Como já havia mencionado no artigo anterior, o Revery funciona muito bem para desenvolver aplicações desktop 
e graças ao suporte [embutido a JSX](https://reasonml.github.io/docs/en/jsx) na sintaxe do Reason, é possível utilizar _"React"_ para desenvolver aplicações 
desktop utilizando Reason com Revery.

_"React" entre aspas mesmo, pois não se trata do mesmo React que conhecemos para web e sim uma implementação 
escrita em ReasonML que segue a mesma API que o React, mas que roda de forma nativa no lado do servidor._

Vale mencionar também o trabalho incrível do [Eduardo](https://twitter.com/TheEduardoRFS), em tentar levar aplicações feitas com Revery para IOS e Android. 
Se quiser saber mais sobre o progresso de Reason na plataforma nativa, vale a pena acompanhar as lives dele na [twitch](https://www.twitch.tv/eduardorfs).

Pretendo fazer alguns posts sobre Reason nativo no futuro, mas por hora quero focar em Reason com React e Reason para ambientes JavaScript.

## Por que ReasonML?

Para responder essa pergunta, vou precisar _"cutucar algumas feridas"_ dos desenvolvedores JavaScript. Vejo uma certa resistência de 
uma parte da comunidade em aceitar que JavaScript tem "características" (problemas de design)  que podem trazer complicações quando falamos de 
colocar softwares em produção e trabalhar em projetos com bases de código consideravelmente grandes e com equipes maiores.

Neste  [artigo]([https://rollbar.com/blog/top-10-javascript-errors/) a Rollbar, 
uma empresa que trabalha com soluções para tracking de erros em aplicações, mostra através de dados coletados da sua platatforma, os __10 erros mais 
comuns em aplicações JavaScript. O que se pode observar é que dos 10 erros listados, 7 deles são o que conhecemos por TypeErrors.

O fato de JavaScript ser uma linguagem dinamicamente e fracamente tipada, 
pode e provavelmente vai te causar problemas em produção em algum momento. Qualquer desenvolvedor JavaScript com uma certa experiência, certamente já passou pela seguinte situação:

*Recebeu um ticket de erro e para entender o problema e o que estava ocorrendo, abriu o console 
e se deparou com a seguinte mensagem:*

![Erro no console](./images/console-error.png)

Isso apesar de ser comum, não deveria ser considerado normal pelos desenvolvedores JavaScript, que com o tempo, acostumou-se com esse tipo de 
erro no ambiente de produção ou até mesmo durante o desenvolvimento. Desenvolvedores JavaScript, estão sempre lidando com esse tipo 
de situação, e o que começou como uma simples _"característica"_ da linguagem, se torna uma dor de cabeça.

![This is fine](./images/this-is-fine.png)

## Como evitar isso?

Bom, existem algumas formas de você evitar que esses erros aconteçam. Uma delas e a mais comum é  *programar de forma defensiva,* o que é péssimo, 
pois no fim, você acaba se preocupando com coisas que não necessariamente você deveria se preocupar, como: _validar se você está somando valores do 
tipo *number* com *strings*, tentar executar um *.map* em algo que não é um *array* e entre outras situações comuns para desenvolvedores JavaScript_.
Por outro lado, existe um esforço em criar ferramentas que cuidem desses detalhes para você, por exemplo linters ou supersets como o TypeScript. 
Certamente utilizar essas ferramentas ou supersets, vão te ajudar a evitar a passar por esses erros de runtime. 

Alguns de vocês devem estar pensando agora: "*ah eu uso TypeScript, então eu já delego essas coisas para a linguagem"*  e é verdade! TypeScript é uma 
opção para lidar com esses problemas. Porém, mesmo com TypeScript você pode acabar se deparando com alguns problemas semelhantes, já que TypeScript 
_"adiciona tipos ao JavaScript" e, o mesmo foi feito para ter uma adoção gradual, ou seja, você ainda pode acabar lidando com essas situações, caso tenha 
que utilizar o famoso *any* nas suas aplicações. 

Diferente do TypeScript ou até mesmo do Flow, Reason não tenta colocar tipos no JavaScript e sim _"colocar JavaScript nos tipos"_, como disse 
o [@fakenickels](https://twitter.com/fakenickels) na sua [talk](https://www.youtube.com/watch?v=q1gPfQHpVjo) de ReasonML na ReactConf. E o quê isso significa? 
Que Reason não vai adicionar um sistema de tipos ao JavaScript 
e sim, trazer a __sintaxe__ do JavaScript para uma linguagem robusta, madura e estaticamente tipada, que é *OCaml.*
Como eu havia dito na primeira parte do artigo, Reason é somente uma nova sintaxe, mais familiar a desenvolvedores JavaScript, para a linguagem OCaml. 

Mesmo que você não passe por problemas e erros de runtime utilizando TypeScript, certamente já se deparou com situações onde seu código se tornou muito 
verboso e rolou anotação de tipos por quase todo o código. E se eu te dissesse que você pode desfrutar das vantagens de 
se utilizar tipos e ainda assim (quase) nunca ter que anotá-los no seu código? Você não os vê, mas eles estão lá. 

Nos próximos trechos, eu vou apresentar um pouco de como funciona o sistema de tipos do ReasonML na prática.

## Tipos em ReasonML

Como eu disse anteriormente, o sistema de tipos de OCaml é incrível e muito poderoso. Ele permite você modelar seu software de uma maneira muito 
clara e sem tirar a elegância da sua sintaxe. Como ReasonML é só uma sintaxe para OCaml, ele herda também o sistema de tipos. 

Não vou falar profundamente sobre como o sistema de tipos de OCaml/ReasonML funciona, daria para fazer uma série inteira falando somente sobre isso. 
Meu objetivo aqui é mostrar a parte prática e o contraste disso com JavaScript e TypeScript. 

O primeiro ponto a se destacar no sistema de tipos de ReasonML, é que quase tudo é inferido. Isso significa que 
você precisa apenas __declarar__ seus tipos, mas não vai precisar __anotá-los__, na hora de utilizar. 

Os exemplos de declaração de variáveis que apresentei na primeira parte do artigo, com valores do tipo *string* e *int* não são um bom exemplo 
de contraste com TypeScript, já que ele também possui uma inferência, mas, que é infinitamente inferior a que ReasonML possui.

Bom, vamos a alguns exemplos:

### Functions

_TypeScript_
```typescript
const sum = (a: number, b: number) => a + b
```
_Reason_
```reason
let sum = (a,b) => a + b;
```

 Observe que eu não anotei nenhum tipo no segundo exemplo. No entanto, o compilador mesmo assim, sabe os tipos. 
 Se tentarmos utilizar esta função da seguinte forma:

```reason
sum("10", 10);
```

O compilador vai mostrar o seguinte erro:

```javascript
  // We've found a bug for you!
 
  1 │ let sum = (a,b) => a + b;
  2 │ 
  3 │ sum(->"10"<-, 10);
  
  This has type:
    string
  But somewhere wanted:
    int
```

O compilador identificou que minha função recebe somente parâmetros do tipo __int__, e em __compile time__ e não em __runtime__ me indicou que estou utilizando a função da maneira errada. 
Mas como ele sabe que esses parâmetros são do tipo __int__? O sistema de tipos consegue analisar a minha expressão __a + b__
e deduzir que os parâmetros só podem ser do tipo int por conta do operador __+__, que em Reason só pode ser utilizado com integers. Dessa forma ele não só consegue nos garantir que estamos utilizando 
a função da maneira correta, como também não exige que você anote os tipos em todas as funções, como ocorre em TypeScript.

_Observe que há diferença entre integers e floats, se estivéssemos trabalhando com valores do tipo float o operador seria __+.__ , 
com um ponto no final e assim sucessivamente para outros operadores como __-.__ e __/.__ ._

## Records

Em Reason não há interfaces como em TypeScript, ao invés disso temos algo bem-parecido, mas muito mais poderoso, que são os *Records* 
e que por padrão já são imutáveis, assim como a maior parte das outras estruturas de dados de ReasonML.

Veja um exemplo de um record abaixo:

```reason
type student = {
 name: string,
 age: int
};
```

Há pouco contraste em relação a TypeScript, observe:

```typescript
interface Student {
 name: string,
 age: int
}
```

A diferença você vai notar ao utilizar e declarar valores do tipo __student__. Vamos analisar dois exemplos que mostram de forma clara as diferenças:

```reason
let student = {
 name: "Alonzo Church",
 age: 22
};
```

```typescript
const student: student = {
 name: "Alonzo Church",
 age: 22
}
```

Observe que da mesma forma que não declarei os tipos dos *parâmetros* no exemplo anterior, na hora de utilizar valores do tipo eu não 
preciso anotá-los, o que não é uma realidade em TypeScript, caso eu queira restringir os valores a um tipo específico.

Veja o que acontece, se tentarmos atribuir a propriedade __age__, um valor que não seja do tipo __int__:

```javascript
  // We've found a bug for you!
  6 │ let student = {
  7 │   name: "Alonzo Church",
  8 │   age: ->"22"<-
  9 │ };
  
  This has type:
    string
  But somewhere wanted:
    int
```

O compilador nos diz que estamos tentando atribuir um valor do tipo *string* onde na verdade, determinamos que deveria ser um *int.*
E assim como no primeiro exemplo, eu não precisei indicar ao compilador do Reason qual o tipo do valor que estou atribuindo a variável _student_,
somente analisando a expressão __`{ name: "Alonzo Church", age: 22 }`__ o compilador vai em busca de tipos que fazem sentido para os _nomes_ e _tipos_ de propriedades
do record que estou declarando.

_Em TypeScript, também é possível criar um objeto assim como este que criamos acima, sem a necessidade de anotar o tipo. No entanto, o compilador do TS não 
irá definir o valor como do tipo student e não irá evitar possíveis erros._

O mesmo vale para se trabalhar funções que utilizam records:

__ReasonML__
```javascript
 let greeting = student => "Hello " ++ student.name;
```

__TypeScript__
```typescript
const greeting = student => "Hello " + student.name

```
Não há necessidade de se anotar o tipo ao parâmetro. O compilador irá sempre analisar a expressão e deduzir qual o seu tipo.

Em casos como esse, onde o parâmetro é um record, o compilador irá analisar a expressão __" Hello" ++ student.name__ e através do
operador __++__, o mesmo sabe que __name__ também é uma string, já que este operador é usado somente para concatenação de strings. Sabendo o tipo
de __name__, ele pode encontrar tipos que encaixem com esse contrato, no caso deste exemplo seriam records que contenham uma propriedade __name__ do tipo __string__.

Como disse no começo desta seção, existem exceções quanto a inferência dos tipos em ReasonML. Records são um ótimo exemplo, já que poderíamos ter
mais de um tipo com uma propriedade __name__, que seja do tipo _string_. Nestes casos especÍficos e não tão comuns assim, a anotação de tipos pode ser necessária.
Vejamos o exemplo abaixo:
```reason
type student = {
  name: string,
};

type person = {
  name: string,
  age: int
};

let getStudentName = student => student.name;

getStudentName({ name: "Alonzo" })
```

- Declaramos um tipo __student__ com uma propriedade __name__ do tipo string.
- Declaramos um tipo __person__ com duas propriedades: __name__ e __age__.
- Definimos uma função __getStudentName__, que recebe um __student__ e retorna __name__.
- Em seguida executamos a função __getStudentName__ passando um valor que se encaixa com o tipo __student__, 
já que possui um __name__ do tipo __string__.

Executando esse código acima, o compilador dará a seguinte mensagem:

```javascript
 
  10 │ let getStudentName = (student) => student.name;
  11 │ 
  12 │ getStudentName({ name: "Alonzo" })
  
  Some record fields are undefined: age
```
O que essa mensagem quer dizer é que estão faltando propriedades no record, que passamos como parâmetro para a função, essa propriedade é __age__.
Logo, o que se pode observar, é que o compilador deduziu que __getStudenName__ não recebe um parâmetro do tipo __student__ e sim do tipo __person__.
Isso ocorre por conta da ordem da declaração dos tipos. Mas isso não é um problema, existem diversos fatores que irão evitar esse tipo de situação,
como o escopo de definição do tipo e declaração das funções. Essas situações são exceções e não regras.

Para informar ao compilador que a função receberá um parâmetro do tipo __student__, você pode anotar o tipo do parâmetro da seguinte forma:
```reason
let getStudentName = (student: student) => student.name;
```

## Null, Undefined & Option

Essa é uma das melhores partes quando se fala do sistema de tipos de OCaml/ReasonML. Diferente de JavaScript e TypeScript,
Reason não possui valores do tipo _null_ ou _undefined_. Esse é também um dos motivos pelo qual utilizar Reason nas suas aplicações 
pode tornar elas "inquebráveis". 

Como falei no começo deste artigo, um dos erros mais comuns é o famigerado **cannot read 'name' property of undefined**.
Em Reason isso jamais vai acontecer, tendo em vista que a linguagem te guia a tratar esses pontos de falha de uma maneira mais elegante, do que programar de forma defensiva.

Basicamente, quando você possui um valor em Reason, que possivelmente pode ser "null", ele vai ser do tipo [option](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Option.html).
Para falar mais sobre como option funciona, eu vou precisar fazer uma leve introdução sobre [variant types](https://dev.realworldocaml.org/variants.html).

### O que são?

Variant types são muito comuns em linguagens funcionais como OCaml. Elas não são tão conhecidas pelos desenvolvedores de linguagens como
Java, JS e C#. No entanto, é um tipo de dado muito poderoso e uma das features mais importantes de OCaml.

A primeira vista, variants podem ser vistas como as enums presentes em TypeScript, mas não se engane, apesar da semelhança elas são muito mais que isso
e abrem uma série de ténicas e possibilidades que te guiam a modelar seu software de uma maneira muito mais coerente.

### Como utilizar?

Vamos a um primeiro exemplo de uso de variant types:

```reason 
  type status =  | Loading | Error | Success;

  let currentStatus = Loading;
```

O código acima, é a declaração de um variant type que pode conter 3 valores: __Loading, Error__ e __Success__. Em seguida atribuimos a variável
**currentStatus**, o valor **Loading**. Essa variável automaticamente se torna do tipo **status**, ou seja, ela poderia tanto ter o valor **Loading**, quanto
**Error** ou **Success**. É possível ver a aplicação desse tipo de dado, em um simples caso como esse exemplo abaixo:

_Pense que o status atual de uma das telas da sua aplicação, está armazenado nessa variável **currentStatus**. Com variant type, você
consegue de forma idiomática, mapear todos os estados desta tela, sendo eles: **Loading, Error** ou **Success**. 
Pense agora que para cada uma dessa possibilidades, teremos uma mensagem de texto para exibir ao usuário:_
- Loading = "Carregando!"
- Error = "Erro!"
- Success = "Tudo certo!"

Em ReasonML, graças a combinação de variants e [pattern matching](https://reasonml.github.io/docs/en/pattern-matching), que não vou me aprofundar neste artigo, você consegue de forma muito declarativa
realizar esse "de-para", veja:

```reason

let getStatusMessage = status => switch status {
  | Loading => "Carregando..."
  | Error => "Erro!"
  | Success => "Tudo certo!"
};

// ...

let currentStatus = Loading;
let statusMessage = getStatusMessage(currentStatus); // Retorno: "Carregando..."
```
O que está acontecendo nessa função, é o seguinte: A função recebe um parâmetro do tipo status e, utilizando um __switch__, que embora seja parecido,
não é um switch case como em JavaScript e sim a sintaxe de pattern matching que havia mencionado anteriormente, você consegue mapear cada possibilidade
que o tipo status possui e dizer ao Reason "_para este tipo, você deve retornar esta string".

Outra coisa essencial sobre variants, é que eles não somente podem ser utilizados como um "símbolo", mas também "segurar um valor" de um determinado tipo.
Vejamos o exemplo abaixo:

```reason
type pet = | Dog(string) | Cat(string);
```
Observe que há um novo elemento nesse exemplo, além de declararmos os _constructors_ do variant __pet__, agora eles "possuem" um valor do tipo string, que nesse exemplo
seria o nome de cada pet. Para utilizar um variant como esse poderíamos fazer algo assim:

```reason
let myPet = Dog("bob");
```
Se fossemos fazer uma função para obter o nome do pet, seja ele __Dog__ ou __Cat__, ficaria algo assim:
```reason
let getPetName = myPet => switch myPet {
  | Dog(name) => "Dog =>" ++ name
  | Cat(name) => "Cat =>" ++ name
}
```
Da mesma forma como no exemplo anterior, é possível utilizar a sintaxe do pattern matching, para encontrar um padrão no valor e, de forma declarativa, 
determinar que para _X_ possibilidade, retorne um valor _Y_. Isso é somente a forma mais básica de se utilizar pattern matching, poderíamos fazer algo mais granular ainda, veja:
```reason
let greeting = myPet => switch myPet {
  | Dog("bob") => "Hello bob!"
  | Dog(anotherName) => "Hi " ++ anotherName
  | Cat(catName) => "The cat =>" ++ catName
}
```
Observe que na primeira possibilidade, ao invés de passar um nome de variável, passei uma string _"bob"_, isso significa que se o valor de __myPet__, for __Dog("bob")__,
ele irá retornar __"Hello bob!"__. Caso não seja este o valor, eu consigo ainda assim mapear essa possibilidade, onde não sei qual o nome de Dog e trata-la.
Por isso se chama __pattern matching__, o intuito é encontrar um padrão e tratá-lo.

Basicamente, essa é a forma que você irá declarar e trabalhar com variants. Nos próximos artigos, com certeza vou me aprofundar e entrar em mais detalhes 
sobre esse tipo dado.

### O variant type "option('a)"

Bom, dada essa introdução e feito um entendimento sobre o que é e como utilizar variants, vou explicar de que forma, isso se relaciona a forma como ReasonML trata
valores que possivelmente serão nulos ou undefined.

Em OCaml, existe um variant type, que vem por padrão na linguagem, chamado **option**. Esse variant possui apenas duas possibilidades: _Some ou None_.
Isso significa que quando tratamos um dado que pode ser undefined ou nulo, em Reason eles serão ou **Some**, algo ou alguma coisa,
ou None, que seria nada ou vazio. O exemplo abaixo mostra como podemos aplicar isso:

```reason
let username = Some("Marcos")
let email = None;
```

Observe que assim como o variant __pet__, o constructor Some, também recebe um valor. No caso do __option__, esse tipo pode ser qualquer coisa,
um número, uma string, um record ou uma lista. Isso é possível graças ao que conhecemos por __parameterized variant__, que basicamente me permite dizer ao compilador do Reason
que meu variant type pode conter um tipo que eu ainda não sei, mas será definido na declaração do valor. Pensando nisso, se fosse necessário declarar o tipo __option__ 
(o que não é, pois é um variant embutido na linguagem) ele ficaria assim:

```reason
type option('a) =  
| Some('a)
| None;
```
Observe atentamente o __'a__. Ele indica ao compilador que nosso variant possui algum valor de um tipo que ainda não sabemos, mas que será definido no momento da declaração.
No entanto, isso não significa que podemos tratar um valor do option, como um Some que possui um valor string em certos momentos e em outros pode possuir um valor do tipo _int_.
Veja o exemplo abaixo, para entender um pouco melhor o que quero dizer:
```reason
let getSomething = value => switch value {
  | Some("Marcos") => "Hello Marcos"
  | Some(10) => "10" // Essa possibilidade não permite que o código compile
  | Some(name) => "Hello " ++ _name_
  | None => "Hello!"
}
```

Se você tentar esse tipo de expressão, o compilador irá imprimir a seguinte mensagem:

```javascript
  1 │ let getSomething = value => switch value {
  2 │   | Some("Marcos") => "Hello Marcos!"
  3 │   | Some(->10<-)=> "10"
  4 │   | Some(name) => "Hello " ++ name
  5 │   | None => "Hello!"
  
  This pattern matches values of type
    ->int<-
  but a pattern was expected which matches values of type
    string
```
Isso é o que garante que você está sempre trabalhando o tipo de dado correto. Se você em sua expressão, deixa explícito ao compilador, que você está trabalhando
com um __Some(string)__, o mesmo irá inferir qualquer outra possibilidade para valores do tipo string e assim sucessivamente para todos os outros tipos existentes na linguagem.

Veja mais um exemplo, onde temos um option que possuirá um valor do tipo __person__:

```reason
type person = { name: string, age: int };

```
Agora pense que esse tipo person, vem na reposta de uma requisição http. Uma requisição http, é um "contato com o mundo externo", é algo que você não controla, logo 
a resposta pode ser um null ou undefined. Esse é o tipo de situação ideal onde o option irá brilhar! Em JavaScript, seria necessário sempre verificar se __person__ não é nulo
ou undefined, para que a aplicação ao tentar acessar alguma propriedade do objeto, não lance um erro em runtime e quebre a aplicação.
Veja como em Reason, isso é fácil de evitar:

```reason
let getPersonName = apiResponse => switch apiResponse {
  | Some(person) => person.name
  | None => "empty"
};
```

Abstraindo a parte de como fazer requisições http com Reason, pense que _getPersonName_ receberá um parâmetro do tipo option e que possuirá um valor do tipo __person__.
Caso __apiResponse__, seja nulo ou undefined por _N_ motivos externos, como uma requisição errada feita a API, nós conseguimos tratar essa possibilidade e impedir
que erros de runtime acontençam. Caso você tente acessar diretamente o name, a partir da variável __apiResponse__, você terá o seguinte erro:

```javascript 
  5 │ apiResponse.->name<-;
  
  This has type:
    option(person)
  But somewhere wanted:
    person
```

Isso significa que é impossível tentar acessar diretamente a propriedade __name__, já que o valor sempre será do tipo _option_.


## Conclusão
Utilizando-se de variants, options, tipagem estática da linguagem OCaml e entre outras features como pattern matching, você será guiado 
a modelar o seu software de uma maneira muito mais clara e coerente. Erros de runtime como os mencionados acima, podem e devem ser delegados
como responsabilidade da linguagem. Além de te tornar produtivo e receber feedback do compilador durante o desenvolvimento, você ainda garante
que tudo vai pra runtime, está sendo manipulado e tratado da maneira correta.

O artigo acabou ficando maior do que eu esperava, mas não consigo ver uma forma melhor de exibir os benefícios, de se adotar ReasonML ao invés de TS ou Flow.
Certamente há uma série de features e técnicas funcionais que ainda nem mencionei, e que também dão um contraste entre ReasonML e as demais opções mencionadas.

Tópicos e conceitos funcionais, pretendo abordar na série sobre como dar os primerios passos com ReasonML. Dessa forma consigo me aprofundar em alguns conceitos e outras
coisas que passaram batidos por este artigo.

A terceira e provavelmente última parte deste artigo, irá abordar somente ReasonML e React. A integração entre ReasonML e React, é um dos pontos mais fortes
na adoção de ReasonML, como alternativa ao JavaScript e, no próximo post vou explicar um pouco mais sobre como essa integração ocorre e como ReasonML e React, 
praticamente, nasceram um para o outro.

Espero ter ajudado você a entender um pouco mais sobre ReasonML e OCaml, seu feedback é importante e faz toda a diferença para construção desses artigos!

<hr />

_Quer enviar um artigo para o blog do BlumenauJS ? Dá uma olhadinha no [repositório](https://github.com/blumenaujs/blog) do blog, é só seguir os passos da documentaçao e abrir um PR._
