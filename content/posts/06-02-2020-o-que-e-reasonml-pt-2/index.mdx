---
title: O que √© ReasonML ? Parte 2
author: Marcos Oliveira
date: 2020-02-08
excerpt: Uma n√£o t√£o breve introdu√ß√£o a ReasonML e o seu ecossistema
---

## Introdu√ß√£o

De in√≠cio quero me desculpar as pessoas que me pediram muito essa segunda parte da s√©rie "O que √© ReasonML?".
Ocorreram muitas mudan√ßas desde o primeiro post e eu acabei deixando de lado essa s√©rie de artigos.
Nesta segunda parte, vou dar continua√ß√£o ao artigo anterior, com objetivo de dar uma vis√£o geral sobre o que √© ReasonML, 
onde ele pode ser usado e o porque voc√™ deveria optar por ele ao inv√©s de TypeScript ou Flow. 

Se voc√™ n√£o leu a primeira parte deste artigo, pare, leia, e volte aqui para continuar. A primeira parte cont√©m informa√ß√µes muito 
importantes sobre ReasonML e vai ser crucial para entender os t√≥picos que irei abordar aqui neste artigo.
Esta √© a segunda e √∫ltima parte da s√©rie, logo quero come√ßar outra que ser√° "Como dar os primeiros passos 
com ReasonML e React". Se tudo der certo tamb√©m devo soltar alguns v√≠deos no canal do [YT](https://www.youtube.com/channel/UCej3xR0REyuvYYAFz0SbswA) 
da [Lukin](https://lukin.co), onde vou passar o mesmo conte√∫do sobre como iniciar em Reason com React, s√≥ que em formato de v√≠deo.

Bom era isso, sem mais delongas, vamos falar de Reason!

## ReasonML üñ§ React

Como disse no primeiro artigo, Reason e React foram criados pela mesma pessoa, o Jordan Walke, e dentro da mesma incubadora, o Facebook. 
Este √© um detalhe crucial para entender alguns aspectos presentes em ReasonML que irei abordar neste artigo.

Reason foi projetado desde o in√≠cio para ser utilizado com React. Isso fica evidente quando vemos a 
integra√ß√£o entre essas duas tecnologias. Reason diferente de langs como TypeScript ou Flow, j√° possui em sua sintaxe suporte a 
JSX, ou seja, o compilador consegue interpretar quando voc√™ escreve utilizando aquela sintaxe bem familiar para devs JS/React: 

```jsx
<MyComponent someProp={1} />
```

Esta √© uma das caracter√≠sticas mais marcantes de Reason! O fato de a sintaxe permitir por padr√£o JSX, tornou 
a compatibilidade com React muito f√°cil. S√≥ para dar um gostinho de como ficaria um componente React, observe o c√≥digo abaixo:

```reason
[@react.component]
let make = (~children) => <div>{children}</div>;
```

N√£o se atenha a partes da sintaxe que ainda n√£o expliquei, mas preste aten√ß√£o apenas na parte similar a JavaScript. 
Este exemplo acima j√° √© um componente React escrito utilizando ReasonML.

_Na s√©rie sobre como dar os primeiros passos com ReasonML e React, vou explicar melhor como funciona exatamente 
cada parte deste c√≥digo e voc√™ ir√° entender ainda mais, como utilizar Reason com React_

_SE√á√ÉO AINDA N√ÉO FINALIZADA_
<hr/>

## Considera√ß√µes sobre Reason nativo

N√£o √© o objetivo deste artigo falar sobre Reason na plataforma nativa, atrav√©s de OCaml. Por√©m √© imposs√≠vel n√£o 
mencionar o trabalho excepcional e com muito potencial que a comunidade ReasonML vem fazendo na plataforma nativa.
Como j√° havia mencionado no artigo anterior, o Revery funciona muito bem para desenvolver aplica√ß√µes desktop 
e gra√ßas ao suporte embutido a JSX na s√≠ntaxe do Reason, √© poss√≠vel utilizar "React" para desenvolver aplica√ß√µes desktop utilizando Reason com o Revery.

_"React" entre aspas mesmo, pois n√£o se trata do mesmo React conhecemos para web e sim uma implementa√ß√£o 
escrita em ReasonML que segue a mesma API que o React, mas que roda de forma nativa no lado do servidor._

Vale mencionar tamb√©m o trabalho incr√≠vel do [Eduardo](https://twitter.com/TheEduardoRFS) em tentar levar aplica√ß√µes feitas com Revery para IOS e Android. 
Vale a pena acompanhar as lives dele na [twitch](https://www.twitch.tv/eduardorfs).

Pretendo fazer alguns posts sobre Reason nativo no futuro, mas por hora quero focar em Reason com React e Reason para ambientes JavaScript.

## Por que ReasonML?

### O problema

Para responder essa pergunta, vou precisar cutucar em algumas "feridas" dos desenvolvedores JavaScript. Vejo uma certa resist√™ncia de 
parte da comunidade em aceitar que JavaScript tem "caracter√≠sticas" (vamos tratar dessa forma)  que podem trazer complica√ß√µes quando falamos de 
colocar softwares em produ√ß√£o e trabalhar em projetos com bases de c√≥digo relativamente grandes e com equipes maiores.

Neste  [artigo]([https://rollbar.com/blog/top-10-javascript-errors/) a Rollbar 
(uma empresa que trabalha com solu√ß√µes para tracking de erros em aplica√ß√µes) mostra, atrav√©s de dados coletados da sua platatforma, os *10 erros mais 
comuns em aplica√ß√µes JavaScript* e o que se pode observar √© que dos 10 erros listados, **7** deles s√£o o que conhecemos por *TypeErrors.*

O fato de JavaScript ser uma linguagem dinamicamente e fracamente tipada, 
pode e provavelmente vai te causar problemas em produ√ß√£o em algum momento. Qualquer desenvolvedor JavaScript com uma certa experi√™ncia, certamente j√° passou pela seguinte situa√ß√£o:

*Recebeu um ticket de erro ou o reportaram que ocorreu um erro em produ√ß√£o e para entender o problema e o que estava ocorrendo, abriu o console 
e  se deparou com a seguinte mensagem:*

![Erro no console](./images/console-error.png)

Isso apesar de ser comum, n√£o deveria ser considerado normal pelos desenvolvedores JavaScript, que com o tempo acostumou-se com esse tipo de 
erro acontecendo no ambiente de produ√ß√£o ou at√© mesmo durante o desenvolvimento. Desenvolvedores JavaScript est√£o sempre lidando com esse tipo 
de situa√ß√£o e o que come√ßou como uma simples *caracter√≠stica* da linguagem, em produ√ß√£o se torna uma dor de cabe√ßa.

![This is fine](./images/this-is-fine.png)

### Como evitar isso?

Bom, existem algumas formas de voc√™ evitar que esses erros aconte√ßam. Uma delas e a mais comum √©  *programar de forma defensiva,* o que √© p√©ssimo, 
pois no fim voc√™ acaba se preocupando com coisas que n√£o necessariamente voc√™ deveria se preocupar como: validar se voc√™ est√° somando valores do 
tipo *number* com *strings* ou tentar executar um *.map* em algo que n√£o √© um *array* e entre outras situa√ß√µes comuns para devs JavaScript.
Por outro lado existe um esfor√ßo em criar ferramentas que cuidem desses detalhes para voc√™, como linters e supersets, como o TypeScript. 
Certamente utilizar essas ferramentas ou supersets, v√£o te ajudar a evitar a passar por esses erros de runtime. 

Alguns de voc√™s devem estar pensando agora "*ah eu uso TypeScript, ent√£o eu j√° delego essas coisas para linguagem"*  e √© verdade! TypeScript √© uma 
op√ß√£o para lidar com esses problemas. Por√©m mesmo com TypeScript voc√™ pode acabar passando por alguns problemas semelhantes, j√° que TypeScript 
"coloca tipos em JS" e o mesmo foi feito para ter uma ado√ß√£o gradual, ou seja, voc√™ ainda pode acabar lidando com essas situa√ß√µes caso tenha 
que utilizar o famoso *any* nas suas aplica√ß√µes. 

Diferente do TypeScript ou at√© mesmo do Flow, Reason n√£o tenta colocar tipos no JavaScript e sim _"colocar JavaScript"_ nos tipos, como disse 
o [@fakenickels](https://twitter.com/fakenickels) na sua [talk](https://www.youtube.com/watch?v=q1gPfQHpVjo) de ReasonML na ReactConf. E o qu√™ isso significa? Que Reason n√£o vai adicionar um sistema de tipos ao JavaScript 
e sim, trazer a s√≠ntaxe do JavaScript para uma linguagem robusta, madura e com um sistema de tipos incr√≠vel que √© *OCaml.*
Como eu havia dito na primeira parte do artigo, Reason √© somente uma nova s√≠ntaxe, mais familiar a devs JavaScript, para a linguagem OCaml. 

Mesmo que voc√™ n√£o passe por problemas e erros de runtime utilizando TypeScript, certamente j√° se deparou com situa√ß√µes onde seu c√≥digo se tornou muito 
verboso e rolou anota√ß√£o de tipos por quase toda a parte do c√≥digo. E se eu te dissesse que voc√™ pode desfrutar das vantagens de 
se utilizar tipos e ainda assim n√£o ter que anota-los (quase nunca) no seu c√≥digo? Voc√™ n√£o os v√™, mas eles est√£o l√°. Nos pr√≥ximos trechos eu 
vou tentar trazer apresentar um pouco de como funciona o sistema de tipos do ReasonML, na pr√°tica.

### Tipos em ReasonML

Como eu disse anteriormente, o sistema de tipos de OCaml √© incr√≠vel e muito poderoso, permite voc√™ modelar seu software de uma maneira muito 
clara e sem tirar a eleg√¢ncia da s√≠ntaxe. Como ReasonML √© s√≥ uma s√≠ntaxe para OCaml, ele herda tamb√©m o sistema de tipos. 

N√£o vou falar profundamente sobre como o sistema de tipos de OCaml/ReasonML funciona, daria para fazer uma s√©rie inteira falando somente sobre isso. 
Meu objetivo aqui √© mostrar a parte pr√°tica e o contraste disso com JavaScript e TypeScript. 

O primeiro ponto a se destacar no sistema de tipos de ReasonML √© que paraticamente tudo √© inferido, sim ***quase*** tudo. Isso significa que 
voc√™ apenas precisa __declarar__ seus tipos, mas n√£o vai precisar __anota-los__ na hora de utilizar. 

Os exemplos de declara√ß√£o de vari√°veis que dei  na primeira parte do artigo, com valores do tipo *string* e *int* n√£o s√£o um bom exemplo 
de contraste com TypeScript, j√° que ele tamb√©m possui uma infer√™ncia, mas, que √© infinitamente inferior a que ReasonML possui.

Bom vamos a alguns exemplos:

***Functions***

_TypeScript_
```typescript
const sum = (a: number, b: number) => a + b
```
_Reason_
```reason
let sum = (a,b) => a + b;
```

 Observe que eu n√£o anotei nenhum tipo no segundo exemplo de Reason. No entanto, o compilador sabe os tipos mesmo. 
 Se tentarmos utilizar esta fun√ß√£o da seguinte forma:

```reason
sum("10", 10);
```

O compilador vai mostrar o seguinte erro:

```javascript
  // We've found a bug for you!
 
  1 ‚îÇ let sum = (a,b) => a + b;
  2 ‚îÇ 
  3 ‚îÇ sum(->"10"<-, 10);
  
  This has type:
    string
  But somewhere wanted:
    int
```

O compilador identificou que minha fun√ß√£o recebe somente par√¢metros do tipo int, e em __compile time__ e n√£o em __runtime__ me indicou que estou utilizando a fun√ß√£o da maneira errada. 
Mas como ele sabe que esses par√¢metros s√£o do tipo __int__? O sistema de tipos consegue analisar a minha express√£o __a + b__
e deduzir que os par√¢metros s√≥ podem ser do tipo int por conta do operador __+__, que em ReasonML s√≥ pode ser utilizado com integers, e dessa forma ele n√£o s√≥ consegue nos garantir que estamos utilizando a fun√ß√£o da maneira correta, como tamb√©m n√£o exige que voc√™ anote os tipos em todas as fun√ß√µes, como ocorre em TypeScript.

_Observe que h√° diferen√ßa entre integers e floats, se estivessemos trabalhando com valores do tipo float o operador seria __+.__ , 
com um ponto no final e assim sucessivamente para outros operadores como __-.__ e __/.__ ._

***Records***

Em Reason n√£o h√° interfaces como em TypeScript, ao inv√©s disso temos algo bem parecido mas muito mais poderoso, que s√£o os *Records* 
e que por padr√£o j√° s√£o imut√°veis, assim como a maior parte das outras estruturas de dados de ReasonML.

Veja um exemplo de um record abaixo:

```reason
type student = {
 name: string,
 age: int
};
```

H√° pouco contraste em rela√ß√£o a TypeScript, observe:

```typescript
interface Student {
 name: string,
 age: int
}
```

A diferen√ßa voc√™ vai notar ao utilizar e declarar valores do tipo student. Vamos analisar dois exemplos que mostram de forma clara as diferen√ßas:

```reason
let student = {
 name: "Alonzo Church",
 age: 22
};
```

```typescript
const student: student = {
 name: "Alonzo Church",
 age: 22
}
```

Observe que da mesma forma que n√£o declarei os tipos dos *par√¢metros* no exemplo anterior, na hora de utilizar valores do tipo eu n√£o 
preciso anota-los, o que n√£o √© uma realidade em TypeScript se eu quiser restringir os valores a um tipo especifico.

Veja o que acontece se eu tentar atribuir a propriedade *age*  um valor diferente de int:

```javascript
  // We've found a bug for you!
  6 ‚îÇ let student = {
  7 ‚îÇ   name: "Alonzo Church",
  8 ‚îÇ   age: ->"22"<-
  9 ‚îÇ };
  
  This has type:
    string
  But somewhere wanted:
    int
```

O compilador nos diz que estamos tentando atribuir um valor do tipo *string* onde na verdade, determinamos que deveria ser um *int.*
E assim como no primeiro exemplo, eu n√£o precisei indicar ao compilador do Reason qual o tipo do valor que estou atribuindo a vari√°vel _student_,
somente analisando a express√£o _**`{ name: "Alonzo Church", age: 22 }`**_ o compilador vai em busca de tipos que fazem sentido para os _nomes_ e _tipos_ de propriedades
do record que estou declarando.

_Em TypeScript tamb√©m √© poss√≠vel criar um objeto assim como este que criamos acima, sem a necessidade de anotar o tipo, entretanto o compilador do TS n√£o 
ir√° definir o valor como do tipo student e n√£o ir√° evitar poss√≠veis erros._

O mesmo vale para se trabalhar fun√ß√µes que utilizam records:

_**ReasonML**_
```javascript
 let greeting = student => "Hello " ++ student.name;
```

_**TypeScript**_
```typescript
const greeting = student => "Hello " + student.name

```
N√£o h√° necessidade de se anotar o tipo ao par√¢metro. O compilador ir√° sempre analisar a express√£o e deduzir qual o tipo do par√¢metro.
Em casos como esse, onde o par√¢metro √© um record, o compilador ir√° analisar a express√£o _**" Hello" ++ student.name**_ e atrav√©s do
operador _++_ o mesmo sabe que _name_ tamb√©m √© uma string, j√° que este operador √© usado somente para concatena√ß√£o de strings. E sabendo o tipo
de _name_ ele pode encontrar tipos que encaixem com esse contrato, no caso deste exemplo seriam records que contenham uma propriedade _name_ do tipo _string_.

Como disse no come√ßo desta se√ß√£o, existem exce√ß√µes quanto a infer√™ncia dos tipos em ReasonML. Records s√£o um √≥timo exemplo, j√° que poderiamos ter
mais de um tipo com uma propriedade _name_ que seja do tipo _string_. Nestes casos especificos e n√£o t√£o comuns assim, a anota√ß√£o de tipos pode ser necess√°ria.
Vejamos o exemplo abaixo:
```reason
type student = {
  name: string,
};

type person = {
  name: string,
  age: int
};

let getStudentName = student => student.name;

getStudentName({ name: "Alonzo" })
```

- Declaramos um tipo student com uma propriedade _**name**_ do tipo string 
- Declaramos um tipo _**person**_ com duas propriedades: _**name**_ e _**age**_
- Definimos uma fun√ß√£o _**getStudentName**_ que recebe um _**student**_ e retorna _**name**_
- Em seguida executamos a fun√ß√£o _**getStudentName**_ passando um valor que se encaixa com o tipo _**student**_, 
j√° que possui um _**name**_ do tipo _**string**_.

Executando esse c√≥digo acima o compilador dar√° a seguinte mensagem:

```javascript
 
  10 ‚îÇ let getStudentName = (student) => student.name;
  11 ‚îÇ 
  12 ‚îÇ getStudentName({ name: "Alonzo" })
  
  Some record fields are undefined: age
```
O que essa mensagem quer dizer √© que est√£o faltando propriedades no record passado como par√¢metro para a fun√ß√£o, e essa propriedade √© _**age**_.
Logo, o que se pode observar √© que o compilador deduziu que _**getStudenName**_ n√£o recebe um par√¢metro do tipo _**student**_ e sim do tipo _**person**_
e isso ocorre por conta da ordem da declara√ß√£o dos tipos. Mas isso n√£o √© um problema, existem diversos fatores que ir√£o evitar esse tipo de situa√ß√£o
como o escopo de defini√ß√£o do tipo e declara√ß√£o das fun√ß√µes. Essas situa√ß√µes s√£o exce√ß√µes e n√£o regras.

Para informar ao compilador que a fun√ß√£o receber√° um par√¢metro do tipo _**student**_, voc√™ pode anotar o tipo do par√¢metro da seguinte forma:
```reason
let getStudentName = (student: student) => student.name;
```

