## Null, Undefined & Option

Essa é uma das melhores partes quando se fala do sistema de tipos de OCaml/ReasonML. Diferente de JavaScript e TypeScript,
Reason não possui valores do tipo _null_ ou _undefined_. Esse é também um dos motivos pelo qual utilizar Reason nas suas aplicações 
pode tornar elas "inquebráveis". 

Como falei no começo deste artigo, um dos erros mais comuns é o famigerado **cannot read 'name' property of undefined**.
Em Reason isso jamais vai acontecer, tendo em vista que a linguagem te guia a tratar esses pontos de falha de uma maneira mais elegante, do que programar de forma defensiva.

Basicamente, quando você possui um valor em Reason, que possivelmente pode ser "null", ele vai ser do tipo [option](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Option.html).
Para falar mais sobre como option funciona, eu vou precisar fazer uma leve introdução sobre [variant types](https://dev.realworldocaml.org/variants.html).

### O que são?

Variant types são muito comuns em linguagens funcionais como OCaml. Elas não são tão conhecidas pelos desenvolvedores de linguagens como
Java, JS e C#. No entanto, é um tipo de dado muito poderoso e uma das features mais importantes de OCaml.

A primeira vista, variants podem ser vistas como as enums presentes em TypeScript, mas não se engane, apesar da semelhança elas são muito mais que isso
e abrem uma série de técnicas e possibilidades que te guiam a modelar seu software de uma maneira muito mais coerente.

### Como utilizar?

Existem basicamente duas foprmas de se utilizar variant types. A primeira, é utilizá-lo como "símbolos" e quando utilizado desta forma, se parecem muito com enums.

**Variants como símbolos**

__ReasonML__
```reason 
  type status =  | Loading | Error | Success;

  let currentStatus = Loading;
```

O código acima, é a declaração de um variant type que pode conter 3 valores: __Loading, Error__ e __Success__. Em seguida atribuimos a variável
**currentStatus**, o valor **Loading**. Essa variável automaticamente se torna do tipo **status**, ou seja, ela poderia tanto ter o valor **Loading**, quanto
**Error** ou **Success**. É possível ver a aplicação desse tipo de dado, em um simples caso como esse exemplo abaixo:

_Pense que o status atual de uma das telas da sua aplicação, está armazenado nessa variável **currentStatus**. Com variant type, você
consegue de forma idiomática, mapear todos os estados desta tela, sendo eles: **Loading, Error** ou **Success**. 
Pense agora que para cada uma dessas possibilidades, teremos uma mensagem de texto para exibir ao usuário:_
- Loading = "Carregando!"
- Error = "Erro!"
- Success = "Tudo certo!"

Em ReasonML, graças a combinação de variants e [pattern matching](https://reasonml.github.io/docs/en/pattern-matching), que não vou me aprofundar neste artigo, você consegue de forma muito declarativa
realizar esse "de-para", veja:

```reason

let getStatusMessage = status => switch status {
  | Loading => "Carregando..."
  | Error => "Erro!"
  | Success => "Tudo certo!"
};

// ...

let currentStatus = Loading;
let statusMessage = getStatusMessage(currentStatus); // Retorno: "Carregando..."
```
O que está acontecendo nessa função, é o seguinte: A função recebe um parâmetro do tipo status e, utilizando um __switch__, que embora seja parecido,
não é um switch case como em JavaScript e sim a sintaxe de pattern matching que havia mencionado anteriormente, você consegue mapear cada possibilidade
que o tipo status possui e dizer ao Reason " para este tipo, você deve retornar esta string".

Outra coisa essencial sobre variants, é que eles não somente podem ser utilizados como um "símbolo", mas também "segurar um valor" de um determinado tipo.
Vejamos o exemplo abaixo:

```reason
type pet = | Dog(string) | Cat(string);
```
Observe que há um novo elemento nesse exemplo, além de declararmos os _constructors_ do variant __pet__, agora eles "possuem" um valor do tipo string, que nesse exemplo
seria o nome de cada pet. Para utilizar um variant como esse poderíamos fazer algo assim:

```reason
let myPet = Dog("bob");
```
Se fossemos fazer uma função para obter o nome do pet, seja ele __Dog__ ou __Cat__, ficaria algo assim:
```reason
let getPetName = myPet => switch myPet {
  | Dog(name) => "Dog =>" ++ name
  | Cat(name) => "Cat =>" ++ name
}
```
Da mesma forma como no exemplo anterior, é possível utilizar a sintaxe do pattern matching, para encontrar um padrão no valor e, de forma declarativa, 
determinar que para _X_ possibilidade, retorne um valor _Y_. Isso é somente a forma mais básica de se utilizar pattern matching, poderíamos fazer algo mais granular ainda, veja:
```reason
let greeting = myPet => switch myPet {
  | Dog("bob") => "Hello bob!"
  | Dog(anotherName) => "Hi " ++ anotherName
  | Cat(catName) => "The cat =>" ++ catName
}
```
Observe que na primeira possibilidade, ao invés de passar um nome de variável, passei uma string _"bob"_, isso significa que se o valor de __myPet__, for __Dog("bob")__,
ele irá retornar __"Hello bob!"__. Caso não seja este o valor, eu consigo ainda assim mapear essa possibilidade, onde não sei qual o nome de Dog e trata-la.
Por isso se chama __pattern matching__, o intuito é encontrar um padrão e tratá-lo.

Basicamente, essa é a forma que você irá declarar e trabalhar com variants. Nos próximos artigos, com certeza vou me aprofundar e entrar em mais detalhes 
sobre esse tipo dado.

### O variant type "option('a)"

Bom, dada essa introdução e feito um entendimento sobre o que é e como utilizar variants, vou explicar de que forma, isso se relaciona a forma como ReasonML trata
valores que possivelmente serão nulos ou undefined.

Em OCaml, existe um variant type, que vem por padrão na linguagem, chamado **option**. Esse variant possui apenas duas possibilidades: _Some ou None_.
Isso significa que quando tratamos um dado que pode ser undefined ou nulo, em Reason eles serão ou **Some**, algo ou alguma coisa,
ou None, que seria nada ou vazio. O exemplo abaixo mostra como podemos aplicar isso:

```reason
let username = Some("Marcos")
let email = None;
```

Observe que assim como o variant __pet__, o constructor Some, também recebe um valor. No caso do __option__, esse tipo pode ser qualquer coisa,
um número, uma string, um record ou uma lista. Isso é possível graças ao que conhecemos por __parameterized variant__, que basicamente me permite dizer ao compilador do Reason
que meu variant type pode conter um tipo que eu ainda não sei, mas será definido na declaração do valor. Pensando nisso, se fosse necessário declarar o tipo __option__ 
(o que não é, pois é um variant embutido na linguagem) ele ficaria assim:

```reason
type option('a) =  
| Some('a)
| None;
```
Observe atentamente o __'a__. Ele indica ao compilador que nosso variant possui algum valor de um tipo que ainda não sabemos, mas que será definido no momento da declaração.
No entanto, isso não significa que podemos tratar um valor do option, como um Some que possui um valor string em certos momentos e em outros pode possuir um valor do tipo _int_.
Veja o exemplo abaixo, para entender um pouco melhor o que quero dizer:
```reason
let getSomething = value => switch value {
  | Some("Marcos") => "Hello Marcos"
  | Some(10) => "10" // Essa possibilidade não permite que o código compile
  | Some(name) => "Hello " ++ name
  | None => "Hello!"
}
```

Se você tentar esse tipo de expressão, o compilador irá imprimir a seguinte mensagem:

```javascript
  1 │ let getSomething = value => switch value {
  2 │   | Some("Marcos") => "Hello Marcos!"
  3 │   | Some(->10<-)=> "10"
  4 │   | Some(name) => "Hello " ++ name
  5 │   | None => "Hello!"
  
  This pattern matches values of type
    ->int<-
  but a pattern was expected which matches values of type
    string
```
Isso é o que garante que você está sempre trabalhando o tipo de dado correto. Se você em sua expressão, deixa explícito ao compilador, que você está trabalhando
com um __Some(string)__, o mesmo irá inferir qualquer outra possibilidade para valores do tipo string e assim sucessivamente para todos os outros tipos existentes na linguagem.

Veja mais um exemplo, onde temos um option que possuirá um valor do tipo __person__:

```reason
type person = { name: string, age: int };

```
Agora pense que esse tipo person, vem na reposta de uma requisição http. Uma requisição http, é um "contato com o mundo externo", é algo que você não controla, logo 
a resposta pode ser um null ou undefined. Esse é o tipo de situação ideal onde o option irá brilhar! Em JavaScript, seria necessário sempre verificar se __person__ não é nulo
ou undefined, para que a aplicação ao tentar acessar alguma propriedade do objeto, não lance um erro em runtime e quebre a aplicação.
Veja como em Reason, isso é fácil de evitar:

```reason
let getPersonName = apiResponse => switch apiResponse {
  | Some(person) => person.name
  | None => "empty"
};
```

Abstraindo a parte de como fazer requisições http com Reason, pense que _getPersonName_ receberá um parâmetro do tipo option e que possuirá um valor do tipo __person__.
Caso __apiResponse__, seja nulo ou undefined por _N_ motivos externos, como uma requisição errada feita a API, nós conseguimos tratar essa possibilidade e impedir
que erros de runtime acontençam. Caso você tente acessar diretamente o name, a partir da variável __apiResponse__, você terá o seguinte erro:

```javascript 
  5 │ apiResponse.->name<-;
  
  This has type:
    option(person)
  But somewhere wanted:
    person
```

Isso significa que é impossível tentar acessar diretamente a propriedade __name__, já que o valor sempre será do tipo _option_.
